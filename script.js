"use strict";
// Рисуем столько котиков, сколько захотим

var drawCats = function (howManyTimes) {
  for (var i = 0; i < howManyTimes; i++) {
    console.log(i + "=^.^=");
  }
};

drawCats(5); // Вмето 10 тут модет быть другое число

let age = 12;
age = 20;
console.log(age);

let numberOfSiblings = 1 + 3;
let numberOfCandies = 8;
console.log(numberOfCandies * numberOfSiblings);

let secondsInAMinute = 60;
let minutesInAHour = 60;
let secondsInAHour = secondsInAMinute * minutesInAHour;
console.log(secondsInAHour);

let hoursInADay = 24;
let secondsInADay = secondsInAHour * hoursInADay;
console.log(secondsInADay);

let dayInAYear = 365;
let secondsInAYear = secondsInADay * dayInAYear;
console.log(secondsInAYear);

let myAge = 8;
let secondsInMyAge = secondsInAYear * myAge;
console.log(secondsInMyAge);

let bingo = 1000000000;
let howYear = bingo / secondsInAYear;
console.log(howYear);

let highFive = 0;
highFive++;
highFive = 1;
highFive++;

console.log(highFive);

let score = 10;
score += 7;
console.log(score);
score += 5;
console.log(score);
score += 3;
console.log(score);
score -= 7;
console.log(score);

let baloons = 100;
baloons *= 2;
console.log(baloons);
baloons /= 4;
console.log(baloons);

let numberNine = 9;
let stringNine = "9";
console.log(numberNine, stringNine);
console.log(typeof numberNine, stringNine);

console.log(numberNine + numberNine);
console.log(stringNine + stringNine);

let greith = "Привет, ";
let myName = "Valentine";
let exclamation = "!";
console.log(greith + myName + exclamation);

let poslanie = "Яблоко высохло единственный раз, будучи теплым яблоком";
console.log(
  poslanie[0] +
    poslanie[7] +
    poslanie[8] +
    poslanie[15] +
    poslanie[33] +
    poslanie[34] +
    poslanie[40] +
    poslanie[41] +
    poslanie[48] +
    poslanie[47]
);

let lowerCase = "эЙ, кАК дЕЛА?";
console.log(
  lowerCase[0].toUpperCase() + lowerCase.slice(1).toLocaleLowerCase()
);

let javaScriptIsCool = true;
console.log(javaScriptIsCool);
/* Оператор && означает «и». в логических выражениях JavaScript выполняет && прежде ||
Вслух его называют «и», либо «и-и», либо «амперсанд-амперсанд» (амперсандом называется символ &). 
Используйте оператор && с двумя булевыми значениями, когда нужно узнать, равны ли они оба true.
*/
let hadShower = true;
let hasBackpack = false;
console.log(hadShower && hasBackpack);

let haddShower = true;
let hassBackpack = true;
console.log(haddShower && hassBackpack);

/* || (ИЛИ) в логических выражениях JavaScript выполняет && прежде ||.
Булевый оператор || означает «или». Так его и следует называть — «или»,
или даже «или-или», хотя некоторые называют его «пайпс», поскольку
среди англоязычных программистов символ | зовется «пайп»
(«труба»).
Используйте оператор || с двумя булевыми значениями для проверки,
что как минимум одно из них равняется true.
*/
let hasApple = true;
let hasOrange = false;
let hasBanana = false;
console.log(hasApple || hasOrange || hasBanana);

/* ! (НЕ)
Оператор ! означает «не» — так его и называйте. Используйте этот
оператор, чтобы превратить false в true или, наоборот, true в false. Это
полезно для работы со значениями-противоположностями.
*/
let isWeekend = true;
let hadsShower = true;
let hadApple = false;
let hadOrange = true;
console.log(isWeekend && hadsShower && (hadApple || hadOrange));

/* Сравнение чисел с помощью булевых значений 
Булевы значения можно использовать для проверки чисел, если эта
проверка подразумевает простой ответ: да или нет. 
*/

let minHeight = 150;
let maxHeight = 120;
let andreiHeight = 151;
console.log(andreiHeight > minHeight, andreiHeight < maxHeight);

/* Равно
Чтобы проверить два числа на точное равенство, используйте тройной знак равенства (===) — это оператор «равно». 
Будьте осторожны, не путайте === с одиночным знаком равенства (=),
поскольку === означает «равны ли эти два числа?», а = означает «положить значение справа в переменную слева».
Иначе говоря, === задает вопрос, а = присваивает переменной значение.
Также с помощью === можно сравнить две строки или два булевых значения. Если же сравнивать так значения разных типов,
ответом всегда будет false.
*/

let mySecretNumber = 1;
let chicoGuess = 1;
let harpoGuess = "1";
let grauchoGuess = 1;
console.log(
  mySecretNumber === chicoGuess,
  mySecretNumber === harpoGuess,
  mySecretNumber === grauchoGuess
);

/* Двойной знак равенства ==
Еще немного запутаю вас: в JavaScript есть еще один оператор сравнения (двойное равно, ==),
который означает «практически равно»

Используйте его для проверки двух значений на соответствие друг другу, даже если одно из них строка,
а другое — число. Все значения принадлежат к тому или иному типу, так что число 5 отличается от строки «5»,
хоть они и выглядят похоже.

Если сравнить их с помощью ===,
JavaScript ответит, что значения не равны. Однако при сравнении через == они окажутся равными.

Cравнивая значения через двойное равно, JavaScript первым делом пытается преобразовать их к одному типу. 
В данном случае булево значение он преобразует в числовое — при этом false становится нулем,
а true — единицей. Поэтому, сравнивая 0 == false, вы получите true!
*/

let numberOne = "0";
let stringOne = false;
console.log(numberOne == stringOne);

let numberrOne = "false";
let stringgOne = false;
console.log(numberrOne == stringgOne);

/* Вас попросили написать JavaScript-код для автоматической
системы управления кинотеатром. Задача состоит в том,
чтобы определить, пускать ли зрителя на фильм «с 12 лет и старше» или нет.
Правила таковы: если посетителю 12 лет или больше,
он может проходить. Если ему еще не исполнилось 12, но его
сопровождает взрослый, пусть тоже проходит. Во всех
остальных случаях вход запрещен.
*/
let minAge = 12;
let userAgeOne = 11;
let userAgeTwo = 12;
let accompanied = true;
console.log(
  minAge === userAgeOne,
  minAge === userAgeTwo,
  minAge === userAgeOne + accompanied
);

/* undefined и null. Оба они означают «пусто», но смысл этого в обоих случаях немного различается.
JavaScript использует значение undefi ned, когда не может найти иного значения.
Например, если, создав новую переменную, вы не присвоите ей
значение с помощью оператора =, ее значением будет undefined.

А значение null обычно используется, чтобы явно обозначить — «тут пусто».
Специально undefi ned обычно ничему не присваивают; 
если вам захочется обозначить, что в переменной «пусто», используйте для этого null.

Иначе говоря, null нужен, чтобы явно показать отсутствие значения, и порой это бывает полезно. 
Например, есть переменная, обозначающая ваш любимый овощ. Если вы терпеть не можете все без
исключения овощи, имеет смысл дать переменной «любимый овощ» значение null.
Этим вы явно покажете любому, кто увидит ваш код, что у вас нет
любимого овоща. Однако если в переменной будет undefi ned, ктонибудь может подумать, 
что вы просто еще не приписали ей значения
*/

let myFavoriteVegitable = null;

/* М А С С И В Ы    []

С помощью массивов JavaScript позволяет создавать и группировать данные более любопытными способами.
А по сути своей массив — всего лишь список, где хранятся другие значения.

Чтобы создать массив со значениями, нужно перечислить эти значения внутри квадратных скобок, разделяя их запятыми.
Отдельные значения, хранящиеся в массиве, называют элементами.

ДОУСТУП К ЭЛЕМЕНТАМ МАССИВА
Чтобы получить доступ к элементам массива, используйте квадратные скобки с индексом нужного вам элемента.

Не обязательно, чтобы все элементы массива были одного типа. В массиве можно хранить и числа, и строки, и вложенные 
массивы.. 
Чтобы обратиться к элементам массива, вложенного в другой массив, нужно использовать вторую пару квадратных скобок.
*/

let dinosaurs = [];
dinosaurs[0] = "Тираннозавр";
dinosaurs[1] = "Велоцираптор";
dinosaurs[2] = "Стегозавр";
dinosaurs[3] = "Трицератопс";
dinosaurs[4] = "Брахиозавр";
dinosaurs[5] = "Птеранодон";
dinosaurs[6] = "Апатозавр";
dinosaurs[7] = "Диплодок";
dinosaurs[8] = "Компсогнат";
dinosaurs[33] = "lox";

dinosaurs[0] = "Тираннозавр рекс";
let myFavoriteDinosaurs = dinosaurs[4] + " и " + dinosaurs[0] + "!";
console.log(dinosaurs);

let dinosaursAndNumbers = [3, ["Компсогнат", "Апатозавр", 343279.21], 21];
console.log(dinosaursAndNumbers[1][0]);

/*console.log(maniacs[maniacs.length - 1]);
 Мы попросили JavaScript вернуть элемент из нашего массива, но вместо числового индекса ввели в 
квадратных скобках выражение: длина массива минус 1. JavaScript нашел свойство maniacs.length со значением 3,
 вычел 1, получив 2, и наконец вернул элемент с индексом 2 — это и есть последний элемент, "Дот"
 */
let maniacs = ["Якко", "Вакко", "Дот"];
console.log(maniacs.length);
console.log(maniacs[maniacs.length - 1]);

/* При вызове метода push происходят две вещи.
Во-первых, в массив добавляется элемент, указанный в скобках. Во-вторых, метод задает новую длину массива. 
Именно эти значения длины появляются в консоли после каждого вызова push.

*/
maniacs.push("пидор");
maniacs.push("уебан");
console.log(maniacs);
console.log(maniacs[3]);

/*Чтобы добавить элемент в начало массива, используйте метод .unshift(элемент)
 */
maniacs.unshift("хуесос");
maniacs.unshift("баран");
console.log(maniacs);
console.log(maniacs[3]);

/* Удаление элементов массива
Убрать из массива последний элемент можно, добавив к его имени .pop().
Метод pop делает сразу два дела: удаляет последний элемент из массива и возвращает этот элемент в виде значения.

Методы push и pop хорошо друг друга дополняют, поскольку порой
нужно работать только с концом массива. Вы можете добавить элемент
в конец вызовом push, а потом, когда это понадобится, забрать его
оттуда
вызовом pop.
*/
let animals = ["Белый медведь", "Мартышка", "Кот", "Пес", "Лама"];
console.log(animals);
let lastAnimal = animals.pop();
console.log(lastAnimal);
console.log(animals);
console.log(animals.pop());
console.log(animals);
console.log(animals.unshift(lastAnimal));
console.log(animals);

/* Чтобы удалить из массива первый элемент, вернув его значение, используйте .shift()
Метод animals.shift() работает аналогично animals.pop(), но элемент берется из начала массива.
*/
let firstAnimal = animals.shift();
console.log(firstAnimal);
console.log(animals);
console.log(animals.push(firstAnimal));
console.log(animals);

/*Объединение массивов     .concat
Чтобы «склеить» два массива, создав таким образом новый массив, используйте команду firstArray.concat(otherArray).
Метод .concat создает массив, в котором элементы из firstArray будут расположены перед элементами из otherArray.
Хоть команда firstArray.concat(otherArray) и возвращает массив, содержащий все элементы из firstArray и otherArray,
сами эти массивы остаются прежними.
Запросив содержимое furryAnimals и scalyAnimals, мы видим, что массивы не изменились.
*/
let furryAnimals = ["Альпака", "Кольцехвостый лемур", "Йети"];
let scalyAnimals = ["Удав", "Годзилла"];
let furryAndscalyAnimals = furryAnimals.concat(scalyAnimals);
console.log(furryAndscalyAnimals);
console.log(furryAnimals);
console.log(scalyAnimals);

/* С помощью concat можно объединить больше чем два массива.
Для этого укажите дополнительные массивы в скобках, разделив их запятыми
*/
let furryyAnimals = ["Альпака", "Кольцехвостый лемур", "Йети"];
let scalyyAnimals = ["Удав", "Годзилла"];
let featheredAnimals = ["Apa", "Додо"];
let allAnimals = furryyAnimals.concat(scalyyAnimals, featheredAnimals);
console.log(allAnimals);
console.log(furryyAnimals);
console.log(scalyyAnimals);
console.log(featheredAnimals);

/* Поиск индекса элемента в массиве
Чтобы выяснить, какой у определенного элемента индекс в массиве, используйте .indexOf("элемент").
Если элемент встречается в массиве больше чем один раз, indexOf
вернет индекс того элемента, который находится ближе к началу массива.
*/
let colors = ["Красный", "Зеленый", "Синий"];
console.log(colors.indexOf("Синий"));
console.log(colors[2]);
console.log(colors.length - 1);

/* Превращаем массив в строку
Воспользовавшись методом .join(), можно соединить все элементы массива в одну большую строку.

Но что если мы не хотим использовать в качестве разделителя запятую?
Нам поможет метод .join ("разделитель"), который делает все 
то же самое, но вместо запятых ставит между элементами выбранный разделитель.
Обратите внимание: разделитель нужно записывать в кавычках — ведь это строка.

Если же в массиве хранятся нестроковые значения, JavaScript преобразует их в строки перед тем, как соединить.
*/
let boringAnimals = ["Мартышка", "кот", "рыба", "ящерица"];
console.log(boringAnimals.join());

let borringAnimals = ["Мартышка", "кот", "рыба", "ящерица"];
console.log(borringAnimals.join(" - "));

let borrringAnimals = ["Мартышка", "кот,", "рыба,", "ящерица"];
console.log(borrringAnimals.join(" и "));

let ages = [11, 23, 345, 34534];
console.log(ages.join(" "));
console.log(typeof ages);

/* Практические примеры работы с массивами
Поиск дороги домой
Представьте, что ваша подруга побывала у вас в гостях, а теперь хочет
показать вам свой дом. Но вот незадача — вы никогда не бывали у нее
раньше, а путь назад вам предстоит проделать в одиночку.
К счастью, вам в голову приходит хитрый способ решения этой проблемы: по дороге к дому подруги вы будете записывать
 возможные ориентиры (телефонную будку, вывеску магазина или аптеки, школу и т.
д.).
А по дороге назад, двигаясь по списку с конца, вычеркивать каждый
встреченный ориентир — так вы всегда будете знать, куда идти
дальше.

*/
let ladmarks = [];
ladmarks.push("мой дом");
console.log(ladmarks);
ladmarks.push("телефонная будка");
console.log(ladmarks);
ladmarks.push("вывеска магазина");
console.log(ladmarks);
ladmarks.push("аптека");
console.log(ladmarks);
ladmarks.push("моя старая школа");
console.log(ladmarks);
ladmarks.push("проститутки");
console.log(ladmarks);
ladmarks.push("дом подруги");
console.log(ladmarks);

ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);
ladmarks.pop();
console.log(ladmarks);

console.log(Math.random() * 10);

console.log(Math.floor(Math.random() * 6));

let randomWords = ["лох", "пидор", "уёба", "чмо", "ущерб"];
// let randomIndex = Math.floor(Math.random() * 5); ЛИБО пример ниже
console.log(randomWords[Math.floor(Math.random() * 5)]);

let phrases = [
  "Да, давай!",
  "Не, не стоит этого делать",
  "Отличная идея!",
  "Ты в своём уме? НЕТ!",
  "Еще один такой вопрос и ты вылетишь отсюда!",
  "Зайка моя, конечно же да!",
];
console.log(phrases[Math.floor(Math.random() * 6)]);

/*ДРАЗНИЛКА
 */
let bodyParts = [" нос ", " голова ", " жопа ", " глаза ", " щеки "];
let fuckPhrases = [
  " ебаная(-ый) ",
  " сморщенная(-ый) ",
  " красивая(-ый) ",
  " прекрасная(-ый) ",
  " дохлая(-ый) ",
];
let examplePhrases = [
  "рыба",
  "динозавр",
  "подмышка",
  "анус",
  "ноздря",
  "пердеж",
];
let bodyPart = bodyParts[Math.floor(Math.random() * 5)];
let fuckPhrase = fuckPhrases[Math.floor(Math.random() * 5)];
let examplePhrase = examplePhrases[Math.floor(Math.random() * 6)];
let randomResuls = "Твоя(-й)" + bodyPart + "как" + fuckPhrase + examplePhrase;

console.log(randomResuls);

let numberString = [3, 2, 1];
let finish = [
  numberString[0],
  " больше",
  ",",
  " чем ",
  numberString[1],
  " больше",
  ", ",
  "чем ",
  numberString[2],
].join("");
console.log(finish);

/*ОБЪЕКТЫ*/

/*     Создание объектов

Для хранения всевозможной информации об одном животном подойдет JavaScript-объект. 
Вот пример объекта, где хранятся сведения о трехногой кошке по имени Гармония.
let cat = {
"legs": 3,
"name": "Гармония",
"color": "Черепаховый"
};
*/

let catt = {
  name: "Гармония",
  legs: 3,
  color: "Черепаховый",
};

console.log(catt.name, catt.color);

let dog = {
  name: "Оладушек",
  age: 6,
  color: "белый",
  bark: "Гав тяф тяф",
};
let cat = {
  name: "Гармония",
  age: 3,
  color: "Черепаховый",
};
console.log(Object.keys(cat));
/*
 Добавлять элементы объекта можно так же, как элементы массива, — но используя строки вместо чисел:
 */
let popugai = {};
popugai.legs = 4;
popugai.name = "Petux";
popugai.color = "Blue";
console.log(popugai);
/*
 Добавление ключей через точку
Новые ключи также можно добавлять через точечную нотацию.
Давайте перепишем этим способом предыдущий пример, то есть создадим пустой объект и заполним его данными:

! Точечную нотацию можно использовать только с объектами, для массивов она не подходит.

 */

let fish = {};
fish.legs = 0;
fish.name = "ksadm";
fish.color = "blue";
console.log(fish.awesome);

/*
Массив друзей
Давайте рассмотрим более сложный пример — массив объектов со
сведениями о друзьях, где в каждый из объектов вложено по еще одному
массиву. Сначала создадим объекты, а затем поместим их в массив.
*/

let katya = {
  name: "Katya",
  age: 15,
  luckyNumbers: [1, 2, 3, 4],
};
let Nadya = {
  name: "Nadya",
  age: 25,
  luckyNumbers: [5, 6, 7, 8],
};
let Dima = {
  name: "Dima",
  age: 20,
  luckyNumbers: [9, 10, 11, 12],
};
let friends = [katya, Nadya, Dima];
console.log(friends[0].luckyNumbers[3]);
/*
 Учет долгов
Предположим, вы решили открыть банк. Вы одолжили друзьям денег
и теперь думаете, как вести учет того, кто и сколько вам должен.
Можно использовать объект как способ связать строку с числом.
Строкой в нашем случае будет имя друга, а числом — сумма, которую
вам должны:
 */

let owedMoney = {};
owedMoney.Vitaliy = 10000;
owedMoney.Vitaliy += 3000;
owedMoney.Irina = 3000;
let itogoOwedMoney = "Итого: " + (owedMoney.Vitaliy + owedMoney.Irina);
console.log(owedMoney);
console.log(itogoOwedMoney);

/*
Хранение информации о фильмах
Предположим, у вас большая коллекция кино на DVD и Bluray. Правда было бы здорово хранить информацию об этих
фильмах на компьютере, чтобы в случае чего быстро найти сведения о том или ином фильме?
Для этого можно создать объект, каждый ключ в котором — это название фильма, а каждое значение — другой объект,
в котором содержится информация об этом фильме. Да, хранящиеся в объекте значения тоже могут быть объектами!
*/

let movies = {
  "В поисках немо": {
    reliseDate: 2003,
    duration: 100,
    format: "DVD",
    actors: ["Альберт Брукс", "Эллен Дедженерес", "Александр Гоулд"],
  },
  "Звездные воины": {
    reliseDate: 1983,
    duration: 134,
    format: "DVD",
    actors: ["Марк Хэмилл", "Харрисон Форд", "Кэрри Фишер"],
  },
  "Гарри Поттер и Кубок огня": {
    reliseDate: 2005,
    duration: 157,
    format: "Blu-ray",
    actors: ["Дэниел Рэдклифф", "Эмма Уотсон", "Руперт Гринт"],
  },
};

let findingNemo = movies["В поисках немо"];
let findingStarWars = movies["Звездные воины"];
let findingGarryPotter = movies["Гарри Поттер и Кубок огня"];

let cars = {
  reliseDate: 2003,
  duration: 187,
  format: "DVD",
  actors: ["Петух", "Овца", "Баран"],
};
movies["Тачки"] = cars;
let findingCars = cars;
console.log(findingCars);

console.log(findingGarryPotter.actors[1]);
console.log(findingGarryPotter.duration);
console.log(Object.keys(movies));

/*
Теперь мы знаем, как устроены объекты JavaScript. Они во многом похожи на массивы и тоже нужны для хранения множества
элементов данных в одном месте. Но есть важное отличие — для доступа к элементам объекта используются строки, тогда как 
элементы массива расположены по числовым индексам. Поэтому массивы отсортированы по порядку, а объекты нет.
*/

/*
УПРАЖНЕНИЯ
Попрактикуйтесь в использовании объектов, выполнив эти упражнения.
#1. Подсчет очков
Представьте, что вы играете в какую-нибудь игру со своими друзьями и вам нужно вести счет. Создайте для этого объект и 
назовите его scores. Пусть ключами будут имена ваших друзей, а значениями — набранные ими очки (0 или больше).
Счет игроков надо будет увеличивать по мере того, как они зарабатывают новые очки.
Как вы будете менять счет игрока, хранящийся в объекте scores?
*/
let scores = {
  Andrew: 0,
  Dima: 0,
  Sasha: 0,
};
let newScores = ++scores.Andrew;
console.log(newScores);
newScores = ++scores.Andrew;
console.log(newScores);
newScores = ++scores.Andrew;
console.log(newScores);
/*ЛИБО */
scores.Andrew++;
let scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
scores.Andrew++;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
scores.Andrew++;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
/*ЛИБО */
scores.Andrew = 1;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
scores.Andrew += 3;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
scores.Andrew += 5;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);
scores.Andrew += 8;
scoresAndrew = "Andrew" + " - " + scores.Andrew + " points";
console.log(scoresAndrew);

scores.Dima = 1;
scores.Dima += 2;
scores.Dima += 5;
scores.Dima += 8;
let scoresDima = "Dima" + " - " + scores.Dima + " points";
console.log(scoresDima);

scores.Sasha = 1;
scores.Sasha += 4;
scores.Sasha += 2;
scores.Sasha += 9;
let scoresSasha = "Sasha" + " - " + scores.Sasha + " points";
console.log(scoresSasha);

/*    УПРАЖНЕНИЯ #2. Вглубь объектов и массивов.
Пускай у вас есть такой объект:
var myCrazyObject = {
"name": "Нелепый объект",
"some array": [7, 9, { purpose: "путаница", number: 123 }, 3.3],
"random animal": "Банановая акула"
};
ВОПРОС!!!
Как одной строкой JavaScript-кода извлечь из этого объекта число 123?
Проверьте свое решение, запустив его в консоли.
*/

let myCrazyObject = {
  name: "Нелепый объект",
  someArray: [7, 9, { purpose: "путаница", number: 123 }, 3.3],
  randomAnimal: "Банановая акула",
};
console.log(myCrazyObject.someArray[2].number);

/* ФРИЛАНСЕР ПО ЖИЗНИ ДОМАШКА
1. Придумай имя переменной для хранения цвета глаз пользователя сайта
2. Объяви две переменных - user и userName. Присвой значение "Вася" переменной userName.
Скопируй значение переменной userName в переменную user.
Введи в консоль переменную user. Результат должен быть Вася
*/
let userColorEyes;
userColorEyes = {
  name: "Blue",
  size: 10,
  diametr: 5.2,
};
console.log(userColorEyes);

userColorEyes.size = 20;
console.log(userColorEyes);

let user = "Вася";
let userName = "Вася";
console.log(user);

let x = 111 % 8;
console.log(`Результат: ${x}`);

/*
IF, ELSE B JAVASCRIPT

Синтаксис
*/
let message = "Фрилансер по жизни";
if (2 > 1) {
  console.log(message);
}

let secondMessage = "Фрилансер!";
let first = 1;
let second = 1;
if (first === second) {
  console.log(secondMessage);
} else if (first < second) {
  console.log("OPA-NA");
} else if (first > 10) {
  console.log("EEEEEESSSS");
} else if (first < 10) {
  console.log("YES!");
} else {
  console.log("условие не выполнено :(");
}

/*
Условный оператор "?"
*/
let messages = "Привет";

if (5 > 6) {
  messageEnd = " , Оля!";
} else {
  messageEnd = " , Вася!";
}

messages += messageEnd;

console.log(messages);
/*
 теперь тот же код, только с оператором "?"
 */

let messagess = "Привет";
let messageEndd = 5 > 20 ? ", Vasya" : ", Olya";

messagess += messageEndd;
console.log(messagess);

if (0) {
  console.log("Лож!");
} else if ("0") {
  console.log("Истина!");
}

let mes = 92 > "11";
let messageee = 92 > "11" && 58 < 100 ? "Истина!" : "Ложь!";
console.log(mes);

/* ЦИКЛЫ FOR и WHILE

WHILE (переводится как "пока") проверяет условие перед каждой итерацией
ПРИМЕР синтаксиса:
пока (тут есть условие) {
	сначала выполняем это;
	потом это;
	потом это;
	и т.д.
}
*/
let num = 0;
while (num < 5) {
  console.log(num);
  num++;
}

let numm = 5;
while (numm) {
  // console.log(numm);
  numm--;
  if (numm == 2) continue;
  console.log(numm);
}

/*
Конструкция DO......WHILE проверяет условие после каждой итерацией
Этот способ стоит использовать тогда, когда нам необходимо хотя бы одно выполнение тела цикла,
независимо от того, вернет условие true или нет
*/

let nummm = 0;
do {
  console.log(nummm);
  nummm++;
} while (nummm < 2);

/*
FOR проверяет условие перед каждой итерацией. Есть возможность задать доп. настройки
Синтаксис:
for (начало; Условие; Шаг) {
	Тут записываем код, который хотим многократно выполнять
}
*/
for (let nem = 0; nem < 5; nem++) {
  console.log(nem);
}
/* Работа цикла for в данном примере:
1) Выполняется начало - let nem = 0;
2) Выполняется условие nem < 5;
3) Если условие стало true, тогда выполняется тело цикла - console.log(nem);
4) Выполняется шаг - nem++.
Повтор цикла for начинается с пункта №2.
*/

/*
 Встроенное объявдение переменной

 В данном случае, если мы попробуем обратиться к переменной за пределами цикла, то у нас это не получится
 НО! Мы можем задать переменную раньше, до назначения цикла и тогда у нас всё получится.
 */
for (let nim = 20; nim > 5; nim--) {
  console.log(nim);
}

let nimm;
for (nimm = 0; nimm < 5; nimm++) {
  console.log(nimm);
}
console.log(`Вывод вне цикла: ${nimm}`);

/* Директива break
Что если в процессе выполнения цикла мы получили то, что хотели и хотим прекратить работу цикла досрочно?
Для этого используем специальную директиву break.

 */
let nkm;
for (nkm = 0; nkm < 5; nkm++) {
  console.log(nkm);
  if (nkm == 2) break;
}
console.log(`Число, которое нам было нужно это ${nkm}`);
/*
Но так же в процессе выполнения цикла мы можем досрочно прекратить работу части тела цикла,
 и перескочить сразу на следующий круг, написав continue
*/
let njm;
for (njm = 0; njm < 5; njm++) {
  if (njm == 2) continue;
  console.log(njm);
}

/* Метки цикла
 */
let nnn;
let size;
firstFor: for (nnn = 0; nnn < 2; nnn++) {
  for (size = 0; size < 3; size++) {
    if (size == 2) {
      break firstFor;
    }
    console.log(size);
  }
}

/*Домашка от фрилансера:
1) Вывести в консоль числа от 1 до 5 всеми циклами, которые сегодня ищучили;
2) let num = 8;
while (num) {
	console.log(num);
	num--
}  последний результат 0, верно?
3) Переписать на while
for (let num = 0; num < 3; num++) {
	console.log(`Число: ${num}`);
}
4) Прекратить работу цикла №1, когда size равна 1
for (let num = 0; num < 2; num++) {
	for (let size = 0; size < 3; size++) {
console,log(size);
	}
	
	
}
*/

/*первая задачка*/
let qqq = 0;
while (qqq < 5) {
  qqq++;
  console.log(qqq);
}

let eee = 0;
do {
  console.log(eee);
  eee++;
} while (eee <= 5);

let www;
for (www = 1; www <= 5; www++) {
  console.log(www);
}

/* Вторая задачка*/
let rrr = 8;
while (rrr) {
  console.log(rrr);
  rrr--;
} /*Нет, последний результат 1. 0 это false и это значение не выводит*/

/*задачка №3*/
for (let num = 0; num < 3; num++) {
  console.log(`Число: ${num}`);
}

let ttt = 0;
while (ttt < 3) {
  ttt++;
  console.log(`число: ${ttt}`);
}

/*ЗАдачка №4*/
firstCikl: for (let num = 0; num < 2; num++) {
  for (let size = 0; size < 3; size++) {
    if (size == 1) {
      break firstCikl;
    }
    console.log(size);
    console.log(`число, на котором остановилась итерация: ${size}`);
  }
}

/*ОБУЧЕНИЕ ПО УЧЕБНИКУ IF, IF...ELSE
конструкция if состоит из двух частей:
условия и тела. Условие должно давать булево значение. А тело — одна или несколько строк JavaScript-кода,
которые будут выполнены, если условие истинно (true).
Конструкция if проверяет, истинно ли условие
if (condition) {
console.log("Делаем что-то");
}
Код, который выполняется, если условие дает true, называется телом if
Если же условие дает false, интерпретатор игнорирует конструкцию if
и переходит к следующей за ней строке.

*/
let names = "Валентин";
console.log("Привет, " + names + "!");
if (names.length > 6) {
  console.log("Ну и длиннющее же у Вас имя!");
}

/*    Конструкция if... else
 оператор if запускает код своего тела, только если
условие дает true. Но если вы хотите, чтобы по условию false тоже
что-то происходило, вам нужна конструкция if... else.
Этот код делает практически то же, что и раньше, однако, если
имя (name) не длиннее 6 символов, он выводит другое, альтернативное
сообщение.

*/
let namess = "Валентин";
console.log("Привет, " + namess + "!");
if (namess.length > 6) {
  console.log("Ну и длиннющее же у Вас имя!");
} else {
  console.log("Имя у Вас не из длинных...");
}
/*
 Зачастую нужно проверить несколько условий и сделать что-то, если
одно из них дает true. Пример: вы пришли в китайский ресторан и
выбираете, что бы такое съесть. Больше всего вы любите курицу с лимоном
(lemon chicken), и, если она есть в меню, вы ее закажете. Если же ее
нет, вы закажете говядину в соусе из черных бобов (beef with black bean).
Однако если и это блюдо отсутствует, вы остановитесь на свинине в кислосладком соусе (sweet and sour pork).
Наконец, в маловероятном случае, когда нет ни одного из этих блюд, вы закажете рис с яйцом, поскольку
знаете, что его подают во всех китайских ресторанах.

 */
let lemonChicken = false;
let beefWithBlackBean = true;
let sweetAndSourPork = false;
if (lemonChicken) {
  console.log("я буду курочку с лемоном!");
} else if (beefWithBlackBean) {
  console.log("Нууу, давайте chicken..");
} else if (sweetAndSourPork) {
  console.log("Свинина.... можно и ее, раз и мяса нет");
} else {
  console.log(
    "Вы смеетесь? у вас нет вообще ничего что ли? Давайте тогда рис и яйцом"
  );
}
/*
Чтобы создать цепочку if... else, начните с обычного оператора if
и после закрывающей фигурной скобки его тела введите ключевые
слова else if, а следом — еще одно условие и еще одно тело. После можно
добавить еще else if, и так до тех пор, пока у вас не закончатся условия
(которых может быть сколько угодно). Завершающая секция else будет
выполнена, если ни одно из условий не дает true.
*/

/*
Для каждого условия указан код, который выполняется, если условие дает true:

if (condition1) {
console.log("Сделай это, если условие 1 истинно");
} else if (condition2) {
console.log("Сделай это, если условие 2 истинно");
} else if (condition3) {
console.log("Сделай это, если условие 3 истинно");
} else {
console.log("Иначе сделай это");
}
Можно прочитать этот код так:
• Если первое условие дает true, выполнить код из первого тела.
• Иначе, если второе условие дает true, выполнить второе тело.
• Иначе, если третье условие дает true, выполнить третье тело.
• Иначе выполнить тело else.

Имея цепочку if... else с завершающей секцией else,
можно не сомневаться, что одно (и только одно) из тел будет
выполнено. Как только выяснится, что одно из условий дает
true, будет запущен код из соответствующего тела, а последующие условия проверяться уже не будут.
*/
/*
 ПОПРОБУЙТЕ !
Напишите программу с переменной name. Если в этой переменной
находится ваше имя, напечатайте: «Привет мне!» — иначе напечатайте: «Привет,
незнакомец!» (Подсказка: используйте === для сравнения переменной name с вашим именем.)
Теперь дополните программу, чтобы она здоровалась с вашим папой,
если в name его имя, и с вашей мамой, если в name ее имя. Если же там
что-то иное, по-прежнему печатайте «Привет, незнакомец!».

 */
let myNameIs = "Alina";
if ("Alina" === myNameIs) {
  console.log("Привет мне!");
} else {
  console.log("Привет, незнакомец!");
}

/*     Циклы

Как мы теперь знаем, условные конструкции позволяют запускать фрагмент кода, если условие дает
true. Циклы, с другой стороны, позволяют выполнять фрагмент кода многократно — до тех пор, пока некое
условие дает true.
Примеры: до тех пор, пока в тарелке есть пища, следует продолжать есть; до тех пор, пока
на лице грязь, следует продолжать умываться.

Цикл while (While — до техпор, пока):
Самый простой из циклов — цикл while. Этот цикл снова и снова
выполняет код своего тела, до тех пор, пока заданное условие не перестанет давать true.

Общая структура цикла while
while (condition) {
console.log("Делаем что-то");
i++;
}

*/

/*
Считаем овец с помощью цикла while
Предположим, у вас проблемы со сном и вы решили посчитать овец.
Но раз уж вы программист, почему бы не написать программу, которая
будет считать овец за вас?

*/

let sheepCounted = 0;
while (sheepCounted <= 100) {
  console.log("Посчитано овец" + ": " + sheepCounted + " шт." + "!");
  sheepCounted++;
}
console.log("zzzzzzzz..... zzzzzzzz........ zzzzzzz.....");

/*        Цикл for

Оператор for упрощает создание циклов, устроенных следующим образом: 
сначала создается переменная, а затем тело цикла выполняется снова и снова до тех пор,
пока условие дает true, причем в конце каждого повтора значение переменной обновляется.
Программируя цикл for, мы создаем переменную, задаем условие, указываем, 
как должна меняться переменная после каждого повтора, — и лишь затем переходим к написанию тела цикла

Общая структура цикла for:
for (настройка; условие; приращение) {
console.log("Делаем что-то");
}
НАСТРОЙКА (var sheepCounted = 0) выполняется до запуска цикла.
Как правило, здесь создают переменную для отслеживания количества
повторов. В нашем случае это переменная sheepCounted с начальным
значением 0.
УСЛОВИЕ (sheepCounted < 10) проверяется перед каждым повто-
ром тела цикла. Если условие дает true, тело выполняется, иначе цикл
заканчивает работу. В нашем случае цикл остановится, когда значение
sheepCounted достигнет 10.
ПРИРАЩЕНИЕ (sheepCounted++) выполняется после каждого
повтора тела цикла. Как правило, здесь изменяют значение переменной цикла. В этом примере мы после каждого повтора увеличиваем
sheepCounted на 1.

Циклы for удобны, когда нужно сделать что-то определенное количество раз.
Например, эта программа три раза выведет слово «Привет!».

var timesToSayHello = 3;
for (var i = 0; i < timesToSayHello; i++) {
console.log("Привет!");
}
*/
let timesToSayHello = 3;
for (var i = 0; i < timesToSayHello; i++) {
  console.log("Привет!");
}
/*Цикл for, массивы и строки
	
Очень часто цикл for используют для перебора всех элементов массива

Условия и циклы 105
Как мы уже знаем из второй главы, к отдельным символам строки
можно обращаться тем же способом, что и к элементам массива, —
с помощью квадратных скобок. В следующем примере цикл for используется для вывода символов имени:
var name = "Ник";
for (var i = 0; i < name.length; i++) {
console.log("В моем имени есть буква " + name[i] + ".");
}
Вот что выдаст эта программа:
В моем имени есть буква Н.
В моем имени есть буква и.
В моем имени есть буква к.

	*/
let animalsForZoo = ["Лев", "Тигр", "Обезьяна", "Волк", "Слон"];
for (i = 0; i < animalsForZoo.length; i++) {
  console.log("В этом зоопарке есть" + ": " + animalsForZoo[i]);
}

/*ПОПРОБУЙТЕ !

Напишите цикл for, который печатает степени тройки, не
превышающие 10 000 (программа должна выводить 3, 9, 27 и т. д.)
Перепишите это задание, вместо for использовав цикл while.
(Подсказка: установите начальное значение перед входом в цикл.)
*/
for (let x = 3; x < 10000; x = x * 10) {
  console.log(x);
}

let q = 3;
while (q < 10000) {
  console.log(q);
  q *= 3;
}
/* Что мы узнали

Мы разобрались с условными конструкциями и циклами. Условные
конструкции нужны, чтобы выполнять некие действия, если условие дает
true. А с помощью циклов можно многократно выполнять фрагмент
кода — до тех пор, пока условие дает true. 
Условными конструкциями можно пользоваться, чтобы запускать код в подходящие для этого
моменты, а циклами — чтобы программа выполнялась так долго, как
требуется. И это открывает перед нами целый мир новых возможностей в программировании 
*/

/*
УПРА ЖНЕНИЯ
Выполните эти упражнения, чтобы попрактиковаться в работе с условными конструкциями и циклами.
#1. Прекрасные животные
Напишите цикл for, который изменяет массив животных, делая их прекрасными! Например, если есть следующий массив:
var animals = ["Кот", "Рыба", "Лемур", "Комодский варан"]; то ваш цикл должен сделать его таким:
["Кот - прекрасное животное", "Рыба - прекрасное животное", "Лемур - прекрасное животное", "Комодский варан - прекрасное животное"]
Подсказка: вам понадобится переприсвоить значения для каждого индекса, то есть присвоить новые значения уже существующим элементам.
Например, сделать первое животное прекрасным можно так:
animals[0] = animals[0] + " - прекрасное животное";

#2. Генератор случайных строк
Напишите генератор случайных строк. Для этого вам понадобится строка со всеми буквами алфавита:
var alphabet = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
Чтобы выбирать из этой строки случайную букву, можно использовать примерно такой же код, как для генератора случайных дразнилок из третьей главы:
Math.fl oor(Math.random() *
alphabet.length). Так вы получите случайный индекс в строке.
Затем, воспользовавшись квадратными скобками, можно получить символ по этому индексу.
Начните создавать случайную строку с пустой строки
(var randomString = ""). Затем добавьте цикл while и при каждом его повторе добавляйте в строку новый случайный
символ — до тех пор, пока длина строки randomString не пре- высит шесть символов (или любой другой длины на ваш выбор).
Добавлять символ в конец строки можно с помощью оператора
+=. После того как цикл закончит работу, выведите получившуюся строку в консоль, чтобы полюбоваться на свое творение!

#3. h4ck3r sp34k
Переведите англоязычный текст на «хакерский язык» (h4ck3r
h4ck3r sp34k —
sp34k)! Многим в интернете нравится заменять некоторые буквы похожими на них числами — например, число «4» похоже
на букву «A», «3» похоже на «E», «1» — на «I», а «0» — на «О». Хотя цифры напоминают скорее заглавные буквы, мы будем заменять
ими буквы строчные. Чтобы перевести обычный текст на «хакерский язык», понадобится строка с исходным текстом и новая
пустая строка для результата:
var input = "javascript is awesome";
var output = "";
Теперь воспользуйтесь циклом for, чтобы перебрать все симвыходное волы исходной строки. Встретив букву «a», добавьте к резульзначение
тирующей строке «4». Встретив «e», добавьте «3», встретив «i», добавьте «1», а встретив «o» — «0». В противном случае просто
добавляйте к результату исходный символ. И снова оператор += отлично подойдет для добавления символа в конец строки.
После завершения цикла выведите результирующую строку в консоль. Если программа работает верно, вы должны увидеть
следующее: "j4v4scr1pt 1s 4w3s0m3".
*/

/*#1. Прекрасные животные
Напишите цикл for, который изменяет массив животных, делая их прекрасными! Например, если есть следующий массив:
var animals = ["Кот", "Рыба", "Лемур", "Комодский варан"]; то ваш цикл должен сделать его таким:
["Кот - прекрасное животное", "Рыба - прекрасное животное", "Лемур - прекрасное животное", "Комодский варан - прекрасное животное"]
Подсказка: вам понадобится переприсвоить значения для каждого индекса, то есть присвоить новые значения уже существующим элементам.
Например, сделать первое животное прекрасным можно так:
animals[0] = animals[0] + " - прекрасное животное";*/

let myAnimals = ["Кот", "Рыба", "Лемур", "Комодский варан"];
for (i = 0; i < myAnimals.length; i++) {
  console.log(myAnimals[i] + " - " + "прекрасное животное" + "!");
}

/*
#2. Генератор случайных строк
Напишите генератор случайных строк. Для этого вам понадобится строка со всеми буквами алфавита:
var alphabet = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
Чтобы выбирать из этой строки случайную букву, можно использовать примерно такой же код, как для генератора случайных дразнилок из третьей главы:
Math.fl oor(Math.random() *
alphabet.length). Так вы получите случайный индекс в строке.
Затем, воспользовавшись квадратными скобками, можно получить символ по этому индексу.
Начните создавать случайную строку с пустой строки (var randomString = "").
Затем добавьте цикл while и при каждом его повторе добавляйте в строку новый случайный
символ — до тех пор, пока длина строки randomString не пре- высит шесть символов (или любой другой длины на ваш выбор).
Добавлять символ в конец строки можно с помощью оператора +=.
После того как цикл закончит работу, выведите получившуюся строку в консоль, чтобы полюбоваться на свое творение!
 */

let alphavite = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";

let randomStrings = "";
while (randomStrings.length < 7) {
  randomStrings += alphavite[Math.floor(Math.random() * alphavite.length)];
}
console.log(randomStrings);

/*
#3. h4ck3r sp34k
Переведите англоязычный текст на «хакерский язык» (h4ck3r sp34k)!
Многим в интернете нравится заменять некоторые буквы похожими на них числами — например, число «4» похоже
на букву «A», «3» похоже на «E», «1» — на «I», а «0» — на «О». Хотя цифры напоминают скорее заглавные буквы, мы будем заменять
ими буквы строчные. Чтобы перевести обычный текст на «хакерский язык», понадобится строка с исходным текстом и новая
пустая строка для результата:
var input = "javascript is awesome";
var output = "";
Теперь воспользуйтесь циклом for, чтобы перебрать все символы исходной строки. Встретив букву «a», добавьте к результирующей строке «4».
Встретив «e», добавьте «3», встретив «i», добавьте «1», а встретив «o» — «0». В противном случае просто
добавляйте к результату исходный символ. И снова оператор += отлично подойдет для добавления символа в конец строки.
После завершения цикла выведите результирующую строку в консоль. Если программа работает верно, вы должны увидеть
следующее: "j4v4scr1pt 1s 4w3s0m3".
*/
// let input = "javascript is awesome";
// let output = "";
// let a = "4";
// let e = "3";
// let i = "1";
// let o = "0";
// for (let x = 0; x < input.length; x++) {
//   if (a) {
//     console.log("4");
//   }
// }

var input = "javascript is awesome";
var output = "";
for (var i = 0; i < input.length; i++) {
  if (input[i] === "a") {
    output += "4";
  } else if (input[i] === "e") {
    output += "3";
  } else if (input[i] === "i") {
    output += "1";
  } else if (input[i] === "o") {
    output += "0";
  } else {
    output += input[i];
  }
}
console.log(output);
